{"version":3,"file":"index.js","names":["value","zValidator: typeof zValidatorFunction"],"sources":["../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Context, Env, Input, MiddlewareHandler, TypedResponse, ValidationTargets } from 'hono'\nimport { validator } from 'hono/validator'\nimport type * as v3 from 'zod/v3'\nimport type { ZodSafeParseResult as v4ZodSafeParseResult } from 'zod/v4'\nimport type * as v4 from 'zod/v4/core'\nimport type { InferInput } from './utils'\n\ntype ZodSchema = v3.ZodType | v4.$ZodType\ntype ZodError<T extends ZodSchema> = T extends v4.$ZodType\n  ? v4.$ZodError<v4.output<T>>\n  : v3.ZodError\ntype ZodSafeParseResult<T, T2, T3 extends ZodSchema> = T3 extends v4.$ZodType\n  ? v4ZodSafeParseResult<T>\n  : v3.SafeParseReturnType<T, T2>\ntype zInput<T> = T extends v3.ZodType ? v3.input<T> : T extends v4.$ZodType ? v4.input<T> : never\ntype zOutput<T> = T extends v3.ZodType ? v3.output<T> : T extends v4.$ZodType ? v4.output<T> : never\ntype zInfer<T> = T extends v3.ZodType ? v3.infer<T> : T extends v4.$ZodType ? v4.infer<T> : never\n\nexport type Hook<\n  T,\n  E extends Env,\n  P extends string,\n  Target extends keyof ValidationTargets = keyof ValidationTargets,\n  O = {},\n  Schema extends ZodSchema = any,\n> = (\n  result: ({ success: true; data: T } | { success: false; error: ZodError<Schema>; data: T }) & {\n    target: Target\n  },\n  c: Context<E, P>\n) => Response | void | TypedResponse<O> | Promise<Response | void | TypedResponse<O>>\n\ntype HasUndefined<T> = undefined extends T ? true : false\n\ntype ExtractValidationResponse<VF> = VF extends (value: any, c: any) => infer R\n  ? R extends Promise<infer PR>\n    ? PR extends TypedResponse<infer T, infer S, infer F>\n      ? TypedResponse<T, S, F>\n      : PR extends Response\n        ? PR\n        : PR extends undefined\n          ? never\n          : never\n    : R extends TypedResponse<infer T, infer S, infer F>\n      ? TypedResponse<T, S, F>\n      : R extends Response\n        ? R\n        : R extends undefined\n          ? never\n          : never\n  : never\n\ntype DefaultInput<Target extends keyof ValidationTargets, In, Out> = {\n  in: HasUndefined<In> extends true\n    ? {\n        [K in Target]?: [In] extends [ValidationTargets[K]] ? In : InferInput<In, K>\n      }\n    : {\n        [K in Target]: [In] extends [ValidationTargets[K]] ? In : InferInput<In, K>\n      }\n  out: { [K in Target]: Out }\n}\n\n// without hook and options\nfunction zValidatorFunction<\n  T extends ZodSchema,\n  Target extends keyof ValidationTargets,\n  E extends Env,\n  P extends string,\n  In = zInput<T>,\n  Out = zOutput<T>,\n  I extends Input = DefaultInput<Target, In, Out>,\n  V extends I = I,\n>(target: Target, schema: T): MiddlewareHandler<E, P, V>\n\n// with hook and options\nfunction zValidatorFunction<\n  T extends ZodSchema,\n  Target extends keyof ValidationTargets,\n  E extends Env,\n  P extends string,\n  HookFn extends Hook<InferredValue, E, P, Target, {}, T>,\n  In = zInput<T>,\n  Out = zOutput<T>,\n  I extends Input = DefaultInput<Target, In, Out>,\n  V extends I = I,\n  InferredValue = zInfer<T>,\n>(\n  target: Target,\n  schema: T,\n  hook?: HookFn,\n  options?: {\n    validationFunction: (\n      schema: T,\n      value: ValidationTargets[Target]\n    ) => ZodSafeParseResult<any, any, T> | Promise<ZodSafeParseResult<any, any, T>>\n  }\n): MiddlewareHandler<E, P, V, ExtractValidationResponse<HookFn>>\n\n// implementation\nfunction zValidatorFunction<\n  T extends ZodSchema,\n  Target extends keyof ValidationTargets,\n  E extends Env,\n  P extends string,\n  HookFn extends Hook<InferredValue, E, P, Target, {}, T>,\n  In = zInput<T>,\n  Out = zOutput<T>,\n  I extends Input = DefaultInput<Target, In, Out>,\n  V extends I = I,\n  InferredValue = zInfer<T>,\n>(\n  target: Target,\n  schema: T,\n  hook?: HookFn,\n  options?: {\n    validationFunction: (\n      schema: T,\n      value: ValidationTargets[Target]\n    ) => ZodSafeParseResult<any, any, T> | Promise<ZodSafeParseResult<any, any, T>>\n  }\n): MiddlewareHandler<E, P, V> | MiddlewareHandler<E, P, V, ExtractValidationResponse<HookFn>> {\n  // @ts-expect-error not typed well\n  return validator(target, async (value: ValidationTargets[Target], c) => {\n    let validatorValue = value\n\n    // in case where our `target` === `header`, Hono parses all of the headers into lowercase.\n    // this might not match the Zod schema, so we want to make sure that we account for that when parsing the schema.\n    if ((target === 'header' && '_def' in schema) || (target === 'header' && '_zod' in schema)) {\n      // create an object that maps lowercase schema keys to lowercase\n      // @ts-expect-error the schema is a Zod Schema\n      const schemaKeys = Object.keys('in' in schema ? schema.in.shape : schema.shape)\n      const caseInsensitiveKeymap = Object.fromEntries(\n        schemaKeys.map((key) => [key.toLowerCase(), key])\n      )\n\n      validatorValue = Object.fromEntries(\n        Object.entries(value).map(([key, value]) => [caseInsensitiveKeymap[key] || key, value])\n      )\n    }\n\n    const result =\n      options && options.validationFunction\n        ? await options.validationFunction(schema, validatorValue)\n        : // @ts-expect-error z4.$ZodType has safeParseAsync\n          await schema.safeParseAsync(validatorValue)\n\n    if (hook) {\n      const hookResult = await hook({ data: validatorValue, ...result, target }, c)\n      if (hookResult) {\n        if (hookResult instanceof Response) {\n          return hookResult\n        }\n\n        if ('response' in hookResult) {\n          return hookResult.response\n        }\n      }\n    }\n\n    if (!result.success) {\n      return c.json(result, 400)\n    }\n\n    return result.data as zInfer<T>\n  })\n}\n\nexport const zValidator: typeof zValidatorFunction = zValidatorFunction\n"],"mappings":";;;AAqGA,SAAS,mBAYP,QACA,QACA,MACA,SAM4F;AAE5F,QAAO,UAAU,QAAQ,OAAO,OAAkC,MAAM;EACtE,IAAI,iBAAiB;AAIrB,MAAK,WAAW,YAAY,UAAU,UAAY,WAAW,YAAY,UAAU,QAAS;GAG1F,MAAM,aAAa,OAAO,KAAK,QAAQ,SAAS,OAAO,GAAG,QAAQ,OAAO,MAAM;GAC/E,MAAM,wBAAwB,OAAO,YACnC,WAAW,KAAK,QAAQ,CAAC,IAAI,aAAa,EAAE,IAAI,CAAC,CAClD;AAED,oBAAiB,OAAO,YACtB,OAAO,QAAQ,MAAM,CAAC,KAAK,CAAC,KAAKA,aAAW,CAAC,sBAAsB,QAAQ,KAAKA,QAAM,CAAC,CACxF;;EAGH,MAAM,SACJ,WAAW,QAAQ,qBACf,MAAM,QAAQ,mBAAmB,QAAQ,eAAe,GAExD,MAAM,OAAO,eAAe,eAAe;AAEjD,MAAI,MAAM;GACR,MAAM,aAAa,MAAM,KAAK;IAAE,MAAM;IAAgB,GAAG;IAAQ;IAAQ,EAAE,EAAE;AAC7E,OAAI,YAAY;AACd,QAAI,sBAAsB,SACxB,QAAO;AAGT,QAAI,cAAc,WAChB,QAAO,WAAW;;;AAKxB,MAAI,CAAC,OAAO,QACV,QAAO,EAAE,KAAK,QAAQ,IAAI;AAG5B,SAAO,OAAO;GACd;;AAGJ,MAAaC,aAAwC"}